#!/bin/bash

# Version management script for trustformers-wasm
# Usage: ./version-manager.sh <command> [version]
# Commands: bump-major, bump-minor, bump-patch, set <version>, current, next

set -e

COMMAND=${1:-"current"}
NEW_VERSION=$2

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${BLUE}üè∑Ô∏è TrustformeRS WASM Version Manager${NC}"

# Function to validate semantic version
validate_version() {
    local version="$1"
    if [[ ! $version =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$ ]]; then
        echo -e "${RED}‚ùå Error: Invalid semantic version format: $version${NC}"
        echo "Expected format: MAJOR.MINOR.PATCH[-prerelease][+build]"
        exit 1
    fi
}

# Function to extract version from Cargo.toml workspace
get_current_version() {
    local workspace_root="../.."
    local workspace_cargo="$workspace_root/Cargo.toml"
    
    if [ -f "$workspace_cargo" ]; then
        # Extract version from workspace Cargo.toml
        grep '^version = ' "$workspace_cargo" | sed 's/version = "\(.*\)"/\1/' | head -1
    else
        # Fallback to git tags
        git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.1.0"
    fi
}

# Function to update version in files
update_version_files() {
    local old_version="$1"
    local new_version="$2"
    
    echo -e "${YELLOW}üìù Updating version in files...${NC}"
    
    # Update workspace Cargo.toml if it exists
    local workspace_cargo="../../Cargo.toml"
    if [ -f "$workspace_cargo" ]; then
        echo "  üìù Updating $workspace_cargo"
        sed -i.bak "s/^version = \"$old_version\"/version = \"$new_version\"/" "$workspace_cargo"
        rm -f "$workspace_cargo.bak"
    fi
    
    # Update package.json files in pkg directories
    for PKG_JSON in pkg-*/package.json; do
        if [ -f "$PKG_JSON" ]; then
            echo "  üìù Updating $PKG_JSON"
            sed -i.bak "s/\"version\": \"$old_version\"/\"version\": \"$new_version\"/" "$PKG_JSON"
            rm -f "$PKG_JSON.bak"
        fi
    done
    
    # Update main package.json if it exists
    if [ -f "package.json" ]; then
        echo "  üìù Updating package.json"
        sed -i.bak "s/\"version\": \"$old_version\"/\"version\": \"$new_version\"/" "package.json"
        rm -f "package.json.bak"
    fi
    
    # Update documentation files with version references
    for DOC_FILE in docs/*.md README.md; do
        if [ -f "$DOC_FILE" ]; then
            # Update version badges and references
            sed -i.bak "s/v$old_version/v$new_version/g" "$DOC_FILE" 2>/dev/null || true
            rm -f "$DOC_FILE.bak" 2>/dev/null || true
        fi
    done
    
    # Update JavaScript files with version references
    for JS_FILE in pkg-*/*.js; do
        if [ -f "$JS_FILE" ]; then
            # Update version strings in JS files
            sed -i.bak "s/version.*$old_version/version: \"$new_version\"/" "$JS_FILE" 2>/dev/null || true
            rm -f "$JS_FILE.bak" 2>/dev/null || true
        fi
    done
    
    echo -e "${GREEN}  ‚úÖ Version files updated${NC}"
}

# Function to increment version
increment_version() {
    local version="$1"
    local part="$2"
    
    # Split version into parts
    IFS='.' read -r -a version_parts <<< "$version"
    major="${version_parts[0]}"
    minor="${version_parts[1]}"
    
    # Handle patch version with potential pre-release
    patch_full="${version_parts[2]}"
    if [[ $patch_full =~ ^([0-9]+)(.*)$ ]]; then
        patch="${BASH_REMATCH[1]}"
        suffix="${BASH_REMATCH[2]}"
    else
        patch="$patch_full"
        suffix=""
    fi
    
    case "$part" in
        "major")
            major=$((major + 1))
            minor=0
            patch=0
            suffix=""
            ;;
        "minor")
            minor=$((minor + 1))
            patch=0
            suffix=""
            ;;
        "patch")
            patch=$((patch + 1))
            suffix=""
            ;;
        *)
            echo -e "${RED}‚ùå Error: Unknown version part: $part${NC}"
            exit 1
            ;;
    esac
    
    echo "$major.$minor.$patch$suffix"
}

# Function to create git tag
create_git_tag() {
    local version="$1"
    local tag="v$version"
    
    echo -e "${YELLOW}üè∑Ô∏è Creating git tag: $tag${NC}"
    
    # Check if tag already exists
    if git tag -l | grep -q "^$tag$"; then
        echo -e "${RED}‚ùå Error: Tag $tag already exists${NC}"
        exit 1
    fi
    
    # Create annotated tag
    git tag -a "$tag" -m "Release version $version

Generated by version-manager.sh on $(date)

Release Notes:
- Automated version bump to $version
- See CHANGELOG.md for detailed changes
- All builds tested and verified

üöÄ TrustformeRS WASM $version is ready for release!"
    
    echo -e "${GREEN}  ‚úÖ Git tag $tag created${NC}"
}

# Function to show next version options
show_next_versions() {
    local current="$1"
    
    echo -e "${BLUE}üìä Version Options:${NC}"
    echo "  Current:    $current"
    echo "  Patch:      $(increment_version "$current" "patch")"
    echo "  Minor:      $(increment_version "$current" "minor")"
    echo "  Major:      $(increment_version "$current" "major")"
}

# Main logic
CURRENT_VERSION=$(get_current_version)

case "$COMMAND" in
    "current")
        echo -e "${GREEN}üìã Current version: $CURRENT_VERSION${NC}"
        ;;
        
    "next")
        show_next_versions "$CURRENT_VERSION"
        ;;
        
    "bump-major"|"bump-minor"|"bump-patch")
        PART=$(echo "$COMMAND" | sed 's/bump-//')
        NEW_VERSION=$(increment_version "$CURRENT_VERSION" "$PART")
        
        echo -e "${YELLOW}üîÑ Bumping $PART version: $CURRENT_VERSION ‚Üí $NEW_VERSION${NC}"
        
        # Confirm with user unless in CI
        if [ -z "$CI" ] && [ -z "$GITHUB_ACTIONS" ]; then
            read -p "Continue? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo -e "${YELLOW}‚èπÔ∏è Cancelled${NC}"
                exit 0
            fi
        fi
        
        validate_version "$NEW_VERSION"
        update_version_files "$CURRENT_VERSION" "$NEW_VERSION"
        
        # Create git commit
        echo -e "${YELLOW}üìù Creating git commit...${NC}"
        git add -A
        git commit -m "chore: bump version to $NEW_VERSION

- Updated version in all package files
- Generated by version-manager.sh
- Ready for release build

[skip ci]"
        
        create_git_tag "$NEW_VERSION"
        
        echo -e "${GREEN}‚úÖ Version bump complete: $CURRENT_VERSION ‚Üí $NEW_VERSION${NC}"
        echo -e "${BLUE}üí° Next steps:${NC}"
        echo "  1. Push changes: git push origin main"
        echo "  2. Push tag: git push origin v$NEW_VERSION"
        echo "  3. GitHub Actions will automatically build and release"
        ;;
        
    "set")
        if [ -z "$NEW_VERSION" ]; then
            echo -e "${RED}‚ùå Error: Version required for 'set' command${NC}"
            echo "Usage: $0 set <version>"
            exit 1
        fi
        
        validate_version "$NEW_VERSION"
        
        echo -e "${YELLOW}üéØ Setting version: $CURRENT_VERSION ‚Üí $NEW_VERSION${NC}"
        
        # Confirm with user unless in CI
        if [ -z "$CI" ] && [ -z "$GITHUB_ACTIONS" ]; then
            read -p "Continue? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo -e "${YELLOW}‚èπÔ∏è Cancelled${NC}"
                exit 0
            fi
        fi
        
        update_version_files "$CURRENT_VERSION" "$NEW_VERSION"
        
        # Create git commit
        echo -e "${YELLOW}üìù Creating git commit...${NC}"
        git add -A
        git commit -m "chore: set version to $NEW_VERSION

- Updated version in all package files
- Generated by version-manager.sh
- Manual version set

[skip ci]"
        
        create_git_tag "$NEW_VERSION"
        
        echo -e "${GREEN}‚úÖ Version set complete: $CURRENT_VERSION ‚Üí $NEW_VERSION${NC}"
        ;;
        
    "help"|"--help"|"-h")
        echo -e "${BLUE}üìñ TrustformeRS WASM Version Manager${NC}"
        echo ""
        echo "Usage: $0 <command> [version]"
        echo ""
        echo "Commands:"
        echo "  current          Show current version"
        echo "  next             Show next version options"
        echo "  bump-major       Increment major version (X.0.0)"
        echo "  bump-minor       Increment minor version (X.Y.0)"
        echo "  bump-patch       Increment patch version (X.Y.Z)"
        echo "  set <version>    Set specific version"
        echo "  help             Show this help"
        echo ""
        echo "Examples:"
        echo "  $0 current"
        echo "  $0 bump-patch"
        echo "  $0 set 1.2.3"
        echo ""
        echo "Features:"
        echo "  ‚Ä¢ Updates all package.json files"
        echo "  ‚Ä¢ Updates workspace Cargo.toml"
        echo "  ‚Ä¢ Updates documentation"
        echo "  ‚Ä¢ Creates git commit and tag"
        echo "  ‚Ä¢ Validates semantic versioning"
        ;;
        
    *)
        echo -e "${RED}‚ùå Error: Unknown command: $COMMAND${NC}"
        echo "Use '$0 help' for usage information"
        exit 1
        ;;
esac

echo -e "${GREEN}üéâ Version management complete!${NC}"