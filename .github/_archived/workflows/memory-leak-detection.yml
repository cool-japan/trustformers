name: Memory Leak Detection

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Run nightly at 2 AM UTC
    - cron: '0 2 * * *'

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  memory-leak-detection:
    name: Memory Leak Detection
    runs-on: ubuntu-latest
    timeout-minutes: 60

    strategy:
      matrix:
        rust-version: [stable, nightly]
        include:
          - rust-version: stable
            use-valgrind: true
          - rust-version: nightly
            use-valgrind: false

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust-version }}
        components: rustfmt, clippy

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          pkg-config \
          libssl-dev \
          valgrind \
          heaptrack

    - name: Cache cargo registry
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-

    - name: Build with memory debugging
      run: |
        export RUSTFLAGS="-C debug-assertions=on -C overflow-checks=on"
        cargo build --workspace --all-features
      env:
        RUST_LOG: debug

    - name: Run memory leak tests (built-in detector)
      run: |
        cargo test --workspace --all-features memory_leak -- --nocapture
      env:
        RUST_LOG: debug
        MEMORY_LEAK_DETECTION: "true"

    - name: Run tensor operation memory tests
      run: |
        cargo test --package trustformers-core --lib testing::test_utils::test_tensor_operations_memory_safe -- --exact --nocapture
      env:
        RUST_LOG: debug

    - name: Run memory leak tests with Valgrind
      if: matrix.use-valgrind
      run: |
        # Create valgrind suppression file for known false positives
        cat > valgrind.supp << 'EOF'
        {
           rust_std_alloc
           Memcheck:Leak
           match-leak-kinds: reachable
           fun:malloc
           ...
           fun:rust_begin_unwind
        }
        {
           rust_thread_local
           Memcheck:Leak
           match-leak-kinds: reachable
           fun:calloc
           ...
           obj:*/libstd-*
        }
        EOF

        # Run tests under Valgrind
        valgrind \
          --tool=memcheck \
          --leak-check=full \
          --show-leak-kinds=all \
          --track-origins=yes \
          --suppressions=valgrind.supp \
          --xml=yes \
          --xml-file=valgrind-results.xml \
          --error-exitcode=1 \
          cargo test --package trustformers-core --lib testing::memory_leak_detector::tests -- --test-threads=1

    - name: Parse Valgrind results
      if: matrix.use-valgrind && always()
      run: |
        if [ -f valgrind-results.xml ]; then
          # Parse Valgrind XML output and create summary
          python3 << 'EOF'
        import xml.etree.ElementTree as ET
        import sys

        try:
            tree = ET.parse('valgrind-results.xml')
            root = tree.getroot()
            
            errors = root.findall('.//error')
            leaks = []
            
            for error in errors:
                kind = error.find('kind')
                if kind is not None and 'Leak' in kind.text:
                    what = error.find('.//what')
                    if what is not None:
                        leaks.append(what.text)
            
            if leaks:
                print("::error title=Memory Leaks Detected::Valgrind found memory leaks")
                for leak in leaks:
                    print(f"::error::{leak}")
                sys.exit(1)
            else:
                print("::notice title=Memory Check Passed::No memory leaks detected by Valgrind")
                
        except Exception as e:
            print(f"::warning title=Valgrind Parse Error::Could not parse Valgrind results: {e}")
        EOF
        fi

    - name: Run heaptrack analysis
      if: matrix.rust-version == 'stable'
      run: |
        # Run a subset of tests with heaptrack for memory profiling
        heaptrack cargo test --package trustformers-core --lib testing::memory_leak_detector::tests::test_memory_leak_detector -- --exact
        
        # Analyze the heaptrack results
        if [ -f heaptrack.*.gz ]; then
          heaptrack_print heaptrack.*.gz > heaptrack-analysis.txt
          
          # Check for potential memory issues in the analysis
          if grep -q "peak heap memory consumption" heaptrack-analysis.txt; then
            echo "::notice title=Heaptrack Analysis::Memory profiling completed successfully"
            
            # Extract peak memory usage
            PEAK_MEMORY=$(grep "peak heap memory consumption" heaptrack-analysis.txt | head -1)
            echo "::notice title=Peak Memory Usage::$PEAK_MEMORY"
          fi
        fi

    - name: Generate memory leak report
      if: always()
      run: |
        # Create a comprehensive memory leak report
        cat > memory-report.md << 'EOF'
        # Memory Leak Detection Report
        
        ## Test Configuration
        - Rust Version: ${{ matrix.rust-version }}
        - Valgrind: ${{ matrix.use-valgrind }}
        - Build Type: Debug with memory debugging enabled
        - Date: $(date -u)
        
        ## Test Results
        EOF
        
        # Add test results to the report
        if [ "${{ job.status }}" = "success" ]; then
          echo "✅ **All memory leak tests passed**" >> memory-report.md
        else
          echo "❌ **Memory leak tests failed**" >> memory-report.md
        fi
        
        echo "" >> memory-report.md
        echo "## Detailed Results" >> memory-report.md
        
        # Add Valgrind results if available
        if [ -f valgrind-results.xml ] && [ "${{ matrix.use-valgrind }}" = "true" ]; then
          echo "### Valgrind Analysis" >> memory-report.md
          echo "Valgrind memory checking completed. See job logs for details." >> memory-report.md
        fi
        
        # Add heaptrack results if available
        if [ -f heaptrack-analysis.txt ]; then
          echo "### Heaptrack Analysis" >> memory-report.md
          echo '```' >> memory-report.md
          head -20 heaptrack-analysis.txt >> memory-report.md
          echo '```' >> memory-report.md
        fi

    - name: Upload memory leak reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: memory-leak-reports-${{ matrix.rust-version }}
        path: |
          memory-report.md
          valgrind-results.xml
          heaptrack-analysis.txt
          memory_leak_junit.xml
          memory_leak_report.md
        retention-days: 30

    - name: Upload JUnit test results
      if: always()
      uses: dorny/test-reporter@v1
      with:
        name: Memory Leak Tests (${{ matrix.rust-version }})
        path: memory_leak_junit.xml
        reporter: java-junit
        fail-on-error: false

    - name: Comment on PR
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          let reportContent = '# Memory Leak Detection Results\n\n';
          
          // Read the generated report if it exists
          try {
            if (fs.existsSync('memory-report.md')) {
              const report = fs.readFileSync('memory-report.md', 'utf8');
              reportContent += report;
            } else {
              reportContent += `Memory leak detection completed for Rust ${{ matrix.rust-version }}.\n`;
              reportContent += `Status: ${{ job.status }}\n`;
            }
          } catch (error) {
            reportContent += `Could not read detailed report: ${error.message}\n`;
          }
          
          // Add workflow summary
          reportContent += '\n\n---\n';
          reportContent += `Workflow: ${{ github.workflow }}\n`;
          reportContent += `Run ID: ${{ github.run_id }}\n`;
          reportContent += `Commit: ${{ github.sha }}\n`;
          
          // Find existing comment or create new one
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const existingComment = comments.find(comment => 
            comment.body.includes('Memory Leak Detection Results')
          );
          
          if (existingComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: reportContent
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: reportContent
            });
          }

  memory-stress-test:
    name: Memory Stress Test
    runs-on: ubuntu-latest
    needs: memory-leak-detection
    if: github.event_name == 'schedule' || github.event_name == 'push'
    timeout-minutes: 120

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y stress-ng htop

    - name: Cache cargo registry
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-stress-${{ hashFiles('**/Cargo.lock') }}

    - name: Build release version
      run: |
        cargo build --workspace --release --all-features

    - name: Run memory stress tests
      run: |
        # Monitor system resources during stress test
        htop -d 1 > system-monitor.log &
        HTOP_PID=$!
        
        # Run stress test with large tensor operations
        timeout 30m cargo test --release --package trustformers-core \
          --lib testing::test_utils::test_tensor_operations_memory_safe \
          -- --exact --ignored
        
        kill $HTOP_PID || true

    - name: Check for memory pressure
      run: |
        # Check if system experienced memory pressure
        if dmesg | grep -i "out of memory\|oom\|memory pressure" | tail -10; then
          echo "::warning title=Memory Pressure::System experienced memory pressure during tests"
        else
          echo "::notice title=Memory Check::No memory pressure detected"
        fi
        
        # Check available memory
        free -h
        
        # Check for core dumps
        if ls core.* 2>/dev/null; then
          echo "::error title=Core Dump::Core dump files found"
          ls -la core.*
        fi

    - name: Upload stress test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: memory-stress-test-results
        path: |
          system-monitor.log
          core.*
        retention-days: 7