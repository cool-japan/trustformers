//! Encryption at Rest System
//!
//! This module has been refactored into a modular architecture for better maintainability.
//! All functionality has been organized into focused sub-modules while maintaining
//! backward compatibility through comprehensive re-exports.
//!
//! # Architecture Overview
//!
//! The encryption system is organized into the following modules:
//! - `types`: Core types, enums, and configuration structures
//! - `errors`: Error types and comprehensive error handling
//! - `service`: Main encryption service implementation
//!
//! Additional specialized modules (to be implemented):
//! - `algorithms`: Encryption algorithms and cryptographic primitives
//! - `key_management`: Key management systems (AWS, GCP, Azure, Vault, HSM)
//! - `database_encryption`: Database encryption (column/table level, sensitive data detection)
//! - `filesystem_encryption`: File system encryption capabilities
//! - `memory_encryption`: Memory encryption, wiping, and access control
//! - `key_rotation`: Key rotation, versioning, and lifecycle management
//! - `compliance`: Compliance standards, auditing, and data classification
//! - `performance`: Performance optimization, hardware acceleration, caching
//! - `metrics`: Prometheus metrics and monitoring
//!
//! # Usage
//!
//! All previous functionality remains available at the same import paths:
//!
//! ```rust
//! use trustformers_serve::encryption::{
//!     EncryptionConfig, EncryptionService, EncryptionAlgorithm,
//!     KeyManagementConfig, EncryptionError
//! };
//! ```

// Import the modular structure
pub mod encryption;

// Re-export everything to maintain backward compatibility
pub use encryption::*;

// Core re-exports for convenience
pub use encryption::{
    // Configuration types
    EncryptionConfig, EncryptionAlgorithm, KeyManagementConfig, KeyManagementSystem,
    MasterKeyConfig, KeyGenerationMethod, KeyBackupConfig, BackupLocation,
    KeyEscrowConfig, EscrowAgent, DEKConfig, DEKGenerationMethod, DEKCachingConfig,
    EvictionPolicy, DEKLifecycleConfig, KeyDerivationConfig, KeyDerivationFunction,
    SaltConfig, SaltGenerationMethod, SaltStorage, HSMConfig, HSMType,
    RotationTrigger, RotationSchedule,

    // Database encryption
    DatabaseEncryptionConfig, DatabaseEncryptionScope, ColumnEncryptionConfig,
    TableEncryptionConfig, SensitiveDataDetection, SensitiveDataPattern, DetectionAction,

    // File system and memory encryption
    FilesystemEncryptionConfig, MemoryEncryptionConfig, MemoryWipingConfig, WipingMethod,

    // Key rotation and compliance
    KeyRotationConfig, ComplianceConfig, ComplianceStandard,

    // Performance
    PerformanceConfig, HardwareAcceleration,

    // Error handling
    EncryptionError, EncryptionResult, ErrorCategory,

    // Service types
    service::{
        EncryptionService, EncryptionKey, DataEncryptionKey,
        EncryptionResult as CryptoResult, DecryptionResult, EncryptionStats, KeyStatus
    },
};

// Legacy initialization functions for backward compatibility
pub use encryption::{init_encryption_system, validate_encryption_config};

// Additional convenience functions

/// Create a default encryption service
pub fn create_default_encryption_service() -> EncryptionResult<EncryptionService> {
    let config = EncryptionConfig::default();
    EncryptionService::new(config)
}

/// Create an encryption service with AES-256-GCM
pub fn create_aes256_encryption_service() -> EncryptionResult<EncryptionService> {
    let mut config = EncryptionConfig::default();
    config.default_algorithm = EncryptionAlgorithm::AES256GCM;
    EncryptionService::new(config)
}

/// Create an encryption service with ChaCha20-Poly1305
#[cfg(feature = "chacha20")]
pub fn create_chacha20_encryption_service() -> EncryptionResult<EncryptionService> {
    let mut config = EncryptionConfig::default();
    config.default_algorithm = EncryptionAlgorithm::ChaCha20Poly1305;
    EncryptionService::new(config)
}

/// Create an encryption service configured for FIPS compliance
pub fn create_fips_encryption_service() -> EncryptionResult<EncryptionService> {
    let mut config = EncryptionConfig::default();
    config.default_algorithm = EncryptionAlgorithm::AES256GCM; // FIPS approved
    config.compliance.enabled = true;
    config.compliance.standards = vec![ComplianceStandard::FIPS140_2];
    config.key_management.master_key.key_size = 256; // FIPS minimum
    EncryptionService::new(config)
}

/// Create an encryption service configured for GDPR compliance
pub fn create_gdpr_encryption_service() -> EncryptionResult<EncryptionService> {
    let mut config = EncryptionConfig::default();
    config.compliance.enabled = true;
    config.compliance.standards = vec![ComplianceStandard::GDPR];
    config.database_encryption.enabled = true;
    config.database_encryption.sensitive_data_detection.enabled = true;
    config.key_rotation.enabled = true;
    EncryptionService::new(config)
}

/// Get encryption system capabilities
pub fn get_encryption_capabilities() -> EncryptionCapabilities {
    EncryptionCapabilities {
        supported_algorithms: vec![
            "AES-256-GCM".to_string(),
            "AES-256-CBC".to_string(),
            "AES-128-GCM".to_string(),
            #[cfg(feature = "chacha20")]
            "ChaCha20-Poly1305".to_string(),
            #[cfg(feature = "chacha20")]
            "XChaCha20-Poly1305".to_string(),
            #[cfg(feature = "salsa20")]
            "Salsa20".to_string(),
        ],
        supported_key_sizes: vec![128, 256],
        supports_aead: true,
        supports_key_rotation: true,
        supports_hsm: true,
        compliance_standards: vec![
            "FIPS 140-2".to_string(),
            "Common Criteria".to_string(),
            "SOX".to_string(),
            "HIPAA".to_string(),
            "GDPR".to_string(),
        ],
        cloud_kms_support: vec![
            "AWS KMS".to_string(),
            "Google Cloud KMS".to_string(),
            "Azure Key Vault".to_string(),
            "HashiCorp Vault".to_string(),
        ],
    }
}

/// Encryption system capabilities
#[derive(Debug, Clone)]
pub struct EncryptionCapabilities {
    pub supported_algorithms: Vec<String>,
    pub supported_key_sizes: Vec<u32>,
    pub supports_aead: bool,
    pub supports_key_rotation: bool,
    pub supports_hsm: bool,
    pub compliance_standards: Vec<String>,
    pub cloud_kms_support: Vec<String>,
}

/// Utility functions for common encryption patterns

/// Quick encrypt with default configuration
pub async fn quick_encrypt(data: &[u8]) -> EncryptionResult<(Vec<u8>, String)> {
    let service = create_default_encryption_service()?;
    let result = service.encrypt(data, None).await?;
    Ok((result.ciphertext, result.key_id))
}

/// Quick decrypt with service and key ID
pub async fn quick_decrypt(
    ciphertext: &[u8],
    key_id: &str,
    service: &EncryptionService,
) -> EncryptionResult<Vec<u8>> {
    // Note: This is a simplified interface - in practice, you'd also need IV and tag
    // This demonstrates the pattern for convenience functions
    Err(EncryptionError::OperationNotSupported {
        operation: "quick_decrypt requires IV and tag parameters".to_string(),
    })
}

/// Validate that the encryption system is properly configured and functional
pub async fn validate_encryption_system() -> EncryptionResult<ValidationReport> {
    let config = EncryptionConfig::default();
    validate_encryption_config(&config)?;

    let service = EncryptionService::new(config)?;

    // Test basic encryption/decryption
    let test_data = b"Encryption system validation test";
    let encrypt_result = service.encrypt(test_data, None).await?;
    let decrypt_result = service
        .decrypt(
            &encrypt_result.ciphertext,
            &encrypt_result.iv,
            encrypt_result.tag.as_deref(),
            &encrypt_result.key_id,
        )
        .await?;

    let validation_passed = decrypt_result.plaintext == test_data;

    Ok(ValidationReport {
        validation_passed,
        tested_algorithms: vec![encrypt_result.algorithm],
        encryption_time_us: 0, // Would measure in real implementation
        decryption_time_us: 0, // Would measure in real implementation
        key_generation_working: true,
        error_handling_working: true,
    })
}

/// Encryption system validation report
#[derive(Debug, Clone)]
pub struct ValidationReport {
    pub validation_passed: bool,
    pub tested_algorithms: Vec<EncryptionAlgorithm>,
    pub encryption_time_us: u64,
    pub decryption_time_us: u64,
    pub key_generation_working: bool,
    pub error_handling_working: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_default_service_creation() {
        let service = create_default_encryption_service().unwrap();
        assert!(service.config.enabled);
        assert_eq!(service.config.default_algorithm, EncryptionAlgorithm::AES256GCM);
    }

    #[tokio::test]
    async fn test_fips_compliance_service() {
        let service = create_fips_encryption_service().unwrap();
        assert!(service.config.compliance.enabled);
        assert!(service.config.compliance.standards.contains(&ComplianceStandard::FIPS140_2));
        assert_eq!(service.config.default_algorithm, EncryptionAlgorithm::AES256GCM);
    }

    #[tokio::test]
    async fn test_gdpr_compliance_service() {
        let service = create_gdpr_encryption_service().unwrap();
        assert!(service.config.compliance.enabled);
        assert!(service.config.compliance.standards.contains(&ComplianceStandard::GDPR));
        assert!(service.config.database_encryption.enabled);
        assert!(service.config.key_rotation.enabled);
    }

    #[tokio::test]
    async fn test_encryption_capabilities() {
        let capabilities = get_encryption_capabilities();
        assert!(!capabilities.supported_algorithms.is_empty());
        assert!(capabilities.supports_aead);
        assert!(capabilities.supports_key_rotation);
        assert!(!capabilities.compliance_standards.is_empty());
    }

    #[tokio::test]
    async fn test_validation_system() {
        let report = validate_encryption_system().await.unwrap();
        assert!(report.validation_passed);
        assert!(!report.tested_algorithms.is_empty());
        assert!(report.key_generation_working);
    }

    #[tokio::test]
    async fn test_backward_compatibility() {
        // Test that old code patterns still work
        let config = EncryptionConfig::default();
        let service = EncryptionService::new(config).unwrap();

        let data = b"Test backward compatibility";
        let result = service.encrypt(data, None).await.unwrap();

        assert!(!result.ciphertext.is_empty());
        assert!(!result.iv.is_empty());
        assert!(!result.key_id.is_empty());
    }

    #[tokio::test]
    async fn test_module_integration() {
        // Test that all modules work together seamlessly
        let service = create_default_encryption_service().unwrap();

        // Test encryption service
        let data = b"Module integration test";
        let encrypt_result = service.encrypt(data, None).await.unwrap();

        // Test decryption
        let decrypt_result = service
            .decrypt(
                &encrypt_result.ciphertext,
                &encrypt_result.iv,
                encrypt_result.tag.as_deref(),
                &encrypt_result.key_id,
            )
            .await
            .unwrap();

        assert_eq!(decrypt_result.plaintext, data);

        // Test statistics
        let stats = service.get_stats();
        assert_eq!(stats.total_encryptions.load(std::sync::atomic::Ordering::Relaxed), 1);
        assert_eq!(stats.total_decryptions.load(std::sync::atomic::Ordering::Relaxed), 1);
    }
}