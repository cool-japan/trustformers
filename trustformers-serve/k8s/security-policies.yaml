# Comprehensive Security Policies for TrustformeRS Serve
# Includes Pod Security Standards, Network Policies, RBAC, and Security Contexts

apiVersion: v1
kind: Namespace
metadata:
  name: trustformers
  labels:
    name: trustformers
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
    security.istio.io/tlsMode: istio

---
# Pod Security Policy (if PSP is enabled)
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: trustformers-serve-psp
  labels:
    app: trustformers-serve
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  runAsGroup:
    rule: 'MustRunAs'
    ranges:
      - min: 1000
        max: 65535
  seLinux:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'MustRunAs'
    ranges:
      - min: 1000
        max: 65535
  readOnlyRootFilesystem: true
  seccompProfile:
    type: RuntimeDefault

---
# Service Account with minimal privileges
apiVersion: v1
kind: ServiceAccount
metadata:
  name: trustformers-serve-production
  namespace: trustformers
  labels:
    app: trustformers-serve
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT:role/TrustformersServeRole
automountServiceAccountToken: false

---
# Role with minimal required permissions
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: trustformers
  name: trustformers-serve-role
  labels:
    app: trustformers-serve
rules:
# Allow reading own pod information
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
  resourceNames: []
# Allow reading configmaps
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list", "watch"]
  resourceNames: ["trustformers-serve-config", "trustformers-serve-env-config"]
# Allow reading secrets
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "watch"]
  resourceNames: ["trustformers-serve-secrets"]
# Allow creating events for logging
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create"]

---
# RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: trustformers-serve-rolebinding
  namespace: trustformers
  labels:
    app: trustformers-serve
subjects:
- kind: ServiceAccount
  name: trustformers-serve-production
  namespace: trustformers
roleRef:
  kind: Role
  name: trustformers-serve-role
  apiGroup: rbac.authorization.k8s.io

---
# Network Policy - Restrictive ingress/egress
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: trustformers-serve-netpol
  namespace: trustformers
  labels:
    app: trustformers-serve
spec:
  podSelector:
    matchLabels:
      app: trustformers-serve
  policyTypes:
  - Ingress
  - Egress
  
  # Ingress rules - very restrictive
  ingress:
  # Allow from ingress controllers
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    - namespaceSelector:
        matchLabels:
          name: istio-system
    ports:
    - protocol: TCP
      port: 8080
    - protocol: TCP
      port: 9090
  
  # Allow from monitoring namespace
  - from:
    - namespaceSelector:
        matchLabels:
          name: trustformers-monitoring
    ports:
    - protocol: TCP
      port: 9091
    - protocol: TCP
      port: 8085
  
  # Allow internal pod-to-pod communication
  - from:
    - podSelector:
        matchLabels:
          app: trustformers-serve
    ports:
    - protocol: TCP
      port: 8080
    - protocol: TCP
      port: 9090
    - protocol: TCP
      port: 9091
  
  # Egress rules - minimal required access
  egress:
  # DNS resolution
  - to: []
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
  
  # HTTPS to external services (model downloads, etc.)
  - to: []
    ports:
    - protocol: TCP
      port: 443
  
  # HTTP for health checks and internal services
  - to: []
    ports:
    - protocol: TCP
      port: 80
  
  # Redis access (if used)
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
  
  # Database access (if used)
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
  
  # Monitoring and tracing
  - to:
    - namespaceSelector:
        matchLabels:
          name: trustformers-monitoring
    ports:
    - protocol: TCP
      port: 4317  # OTLP gRPC
    - protocol: TCP
      port: 4318  # OTLP HTTP
    - protocol: TCP
      port: 14268 # Jaeger

---
# Istio Security Policies
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: trustformers-serve-peer-auth
  namespace: trustformers
  labels:
    app: trustformers-serve
spec:
  selector:
    matchLabels:
      app: trustformers-serve
  mtls:
    mode: STRICT

---
# Istio Authorization Policy
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: trustformers-serve-authz
  namespace: trustformers
  labels:
    app: trustformers-serve
spec:
  selector:
    matchLabels:
      app: trustformers-serve
  rules:
  # Allow health checks
  - to:
    - operation:
        paths: ["/health", "/health/*"]
        methods: ["GET"]
  
  # Allow metrics collection
  - from:
    - source:
        namespaces: ["trustformers-monitoring"]
    to:
    - operation:
        paths: ["/metrics"]
        methods: ["GET"]
  
  # Allow authenticated inference requests
  - from:
    - source:
        principals: ["cluster.local/ns/trustformers/sa/trustformers-client"]
    to:
    - operation:
        paths: ["/v1/*"]
        methods: ["POST", "GET"]
    when:
    - key: request.headers[authorization]
      values: ["Bearer *"]

---
# Open Policy Agent (OPA) Gatekeeper Constraint Template
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredsecuritycontext
  labels:
    app: trustformers-serve
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredSecurityContext
      validation:
        type: object
        properties:
          runAsNonRoot:
            type: boolean
          readOnlyRootFilesystem:
            type: boolean
          allowPrivilegeEscalation:
            type: boolean
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredsecuritycontext

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.runAsNonRoot
          msg := "Container must set runAsNonRoot to true"
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.readOnlyRootFilesystem
          msg := "Container must set readOnlyRootFilesystem to true"
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.securityContext.allowPrivilegeEscalation == true
          msg := "Container must set allowPrivilegeEscalation to false"
        }

---
# Gatekeeper Constraint
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredSecurityContext
metadata:
  name: trustformers-security-context
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment"]
    namespaces: ["trustformers"]
    labelSelector:
      matchLabels:
        app: trustformers-serve
  parameters:
    runAsNonRoot: true
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false

---
# Pod Disruption Budget for availability
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: trustformers-serve-pdb
  namespace: trustformers
  labels:
    app: trustformers-serve
spec:
  minAvailable: 60%
  selector:
    matchLabels:
      app: trustformers-serve
      tier: production

---
# Resource Quota to prevent resource exhaustion
apiVersion: v1
kind: ResourceQuota
metadata:
  name: trustformers-quota
  namespace: trustformers
spec:
  hard:
    requests.cpu: "20"
    requests.memory: 40Gi
    limits.cpu: "40"
    limits.memory: 80Gi
    persistentvolumeclaims: "10"
    pods: "20"
    secrets: "10"
    configmaps: "20"
    services: "10"

---
# Limit Range for default resource constraints
apiVersion: v1
kind: LimitRange
metadata:
  name: trustformers-limits
  namespace: trustformers
spec:
  limits:
  - default:
      cpu: "2"
      memory: "4Gi"
      ephemeral-storage: "10Gi"
    defaultRequest:
      cpu: "500m"
      memory: "1Gi"
      ephemeral-storage: "1Gi"
    max:
      cpu: "8"
      memory: "16Gi"
      ephemeral-storage: "50Gi"
    min:
      cpu: "100m"
      memory: "256Mi"
      ephemeral-storage: "1Gi"
    type: Container
  - default:
      storage: "10Gi"
    max:
      storage: "100Gi"
    min:
      storage: "1Gi"
    type: PersistentVolumeClaim

---
# Security Context Constraints for OpenShift (if applicable)
apiVersion: security.openshift.io/v1
kind: SecurityContextConstraints
metadata:
  name: trustformers-serve-scc
  labels:
    app: trustformers-serve
allowHostDirVolumePlugin: false
allowHostIPC: false
allowHostNetwork: false
allowHostPID: false
allowHostPorts: false
allowPrivilegedContainer: false
allowedCapabilities: []
allowedFlexVolumes: []
allowedUnsafeSysctls: []
defaultAddCapabilities: []
defaultAllowPrivilegeEscalation: false
forbiddenSysctls:
  - "*"
fsGroup:
  type: MustRunAs
  ranges:
    - min: 1000
      max: 65535
readOnlyRootFilesystem: true
requiredDropCapabilities:
  - ALL
runAsUser:
  type: MustRunAsNonRoot
seLinuxContext:
  type: MustRunAs
  seLinuxOptions:
    user: system_u
    role: system_r
    type: container_t
    level: s0
supplementalGroups:
  type: MustRunAs
  ranges:
    - min: 1000
      max: 65535
users:
  - system:serviceaccount:trustformers:trustformers-serve-production
volumes:
  - configMap
  - emptyDir
  - persistentVolumeClaim
  - projected
  - secret
  - downwardAPI

---
# Falco Rule for runtime security monitoring
apiVersion: v1
kind: ConfigMap
metadata:
  name: trustformers-falco-rules
  namespace: trustformers-monitoring
  labels:
    app: falco
data:
  trustformers_rules.yaml: |
    - rule: Trustformers Unexpected Network Connection
      desc: Detect unexpected network connections from TrustformeRS pods
      condition: >
        (inbound_outbound) and
        k8s.ns.name = "trustformers" and
        k8s.pod.label.app = "trustformers-serve" and
        not fd.sport in (8080, 9090, 9091, 8085) and
        not fd.dport in (443, 80, 53, 6379, 5432, 4317, 4318, 14268)
      output: >
        Unexpected network connection from TrustformeRS
        (connection=%fd.name user=%user.name command=%proc.cmdline
        pod=%k8s.pod.name ns=%k8s.ns.name)
      priority: WARNING
      tags: [network, trustformers]

    - rule: Trustformers Sensitive File Access
      desc: Detect access to sensitive files in TrustformeRS pods
      condition: >
        open_read and
        k8s.ns.name = "trustformers" and
        k8s.pod.label.app = "trustformers-serve" and
        (fd.name startswith /etc/passwd or
         fd.name startswith /etc/shadow or
         fd.name startswith /root/. or
         fd.name startswith /home/)
      output: >
        Sensitive file access in TrustformeRS
        (file=%fd.name user=%user.name command=%proc.cmdline
        pod=%k8s.pod.name ns=%k8s.ns.name)
      priority: WARNING
      tags: [filesystem, trustformers]

    - rule: Trustformers Privilege Escalation
      desc: Detect privilege escalation attempts in TrustformeRS pods
      condition: >
        spawned_process and
        k8s.ns.name = "trustformers" and
        k8s.pod.label.app = "trustformers-serve" and
        (proc.name in (su, sudo, setuid) or
         proc.args contains "chmod +s")
      output: >
        Privilege escalation attempt in TrustformeRS
        (command=%proc.cmdline user=%user.name
        pod=%k8s.pod.name ns=%k8s.ns.name)
      priority: HIGH
      tags: [privilege_escalation, trustformers]

---
# Admission Controller Webhook for custom validation
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingAdmissionWebhook
metadata:
  name: trustformers-security-validator
spec:
  clientConfig:
    service:
      name: trustformers-admission-webhook
      namespace: trustformers-monitoring
      path: "/validate"
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: ["apps"]
    apiVersions: ["v1"]
    resources: ["deployments"]
    namespaceSelector:
      matchLabels:
        name: trustformers
  admissionReviewVersions: ["v1", "v1beta1"]
  sideEffects: None
  failurePolicy: Fail