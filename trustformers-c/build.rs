use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    // Set environment variables for compilation
    let build_date = std::process::Command::new("date")
        .arg("+%Y-%m-%d %H:%M:%S UTC")
        .output()
        .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
        .unwrap_or_else(|_| "unknown".to_string());
    println!("cargo:rustc-env=BUILD_DATE={}", build_date);

    let target = env::var("TARGET").unwrap_or_else(|_| {
        format!(
            "{}-{}",
            env::var("CARGO_CFG_TARGET_ARCH").unwrap_or("unknown".to_string()),
            env::var("CARGO_CFG_TARGET_OS").unwrap_or("unknown".to_string())
        )
    });
    println!("cargo:rustc-env=TARGET={}", target);

    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let package_name = env::var("CARGO_PKG_NAME").unwrap();
    let output_dir = target_dir().join("include").join(&package_name);

    // Create output directory
    fs::create_dir_all(&output_dir).expect("Failed to create output directory");

    // Apply cross-platform optimizations
    apply_cross_platform_optimizations();

    // Generate C header
    let config =
        cbindgen::Config::from_file("cbindgen.toml").unwrap_or_else(|_| default_cbindgen_config());

    match cbindgen::generate_with_config(&crate_dir, config) {
        Ok(bindings) => {
            bindings.write_to_file(output_dir.join("trustformers.h"));
        },
        Err(e) => {
            println!(
                "cargo:warning=Failed to generate bindings with cbindgen: {:?}",
                e
            );
            println!("cargo:warning=Falling back to manual header generation");

            // Generate a basic header file manually
            let manual_header = generate_manual_header();
            std::fs::write(output_dir.join("trustformers.h"), manual_header)
                .expect("Failed to write manual header");
        },
    }

    // Copy additional header files if they exist
    let include_dir = PathBuf::from(&crate_dir).join("include");
    if include_dir.exists() {
        copy_dir_all(&include_dir, &output_dir).ok();
    }

    // Generate pkg-config file
    generate_pkgconfig_file(&output_dir);

    // Generate CMake config file
    generate_cmake_config(&output_dir);

    // Generate vcpkg portfile for Windows
    generate_vcpkg_portfile(&output_dir);

    // Generate Meson build file
    generate_meson_build(&output_dir);

    // Automated header file synchronization
    automated_header_sync(&crate_dir, &output_dir);

    println!("cargo:rerun-if-changed=src/");
    println!("cargo:rerun-if-changed=cbindgen.toml");
    println!("cargo:rerun-if-changed=include/");
}

fn target_dir() -> PathBuf {
    if let Ok(target) = env::var("CARGO_TARGET_DIR") {
        PathBuf::from(target)
    } else {
        PathBuf::from(env::var("OUT_DIR").unwrap())
            .ancestors()
            .nth(2)
            .unwrap()
            .to_path_buf()
    }
}

fn default_cbindgen_config() -> cbindgen::Config {
    cbindgen::Config {
        namespace: Some("TrustformeRS".to_string()),
        language: cbindgen::Language::C,
        style: cbindgen::Style::Both,
        cpp_compat: true,
        header: Some("/* TrustformeRS C API\n * High-performance transformer library\n * Generated automatically - do not edit\n */".to_string()),
        include_guard: Some("TRUSTFORMERS_H".to_string()),
        pragma_once: true,
        includes: vec![
            "stdint.h".to_string(),
            "stdlib.h".to_string(),
            "stdbool.h".to_string(),
        ],
        sys_includes: vec![],
        no_includes: false,
        after_includes: Some("#ifdef __cplusplus\nextern \"C\" {\n#endif".to_string()),
        trailer: Some("#ifdef __cplusplus\n}\n#endif".to_string()),
        autogen_warning: Some(
            "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"
                .to_string(),
        ),
        include_version: true,
        ..Default::default()
    }
}

fn copy_dir_all(src: &PathBuf, dst: &PathBuf) -> std::io::Result<()> {
    fs::create_dir_all(dst)?;
    for entry in fs::read_dir(src)? {
        let entry = entry?;
        let ty = entry.file_type()?;
        if ty.is_dir() {
            copy_dir_all(&entry.path(), &dst.join(entry.file_name()))?;
        } else {
            fs::copy(entry.path(), dst.join(entry.file_name()))?;
        }
    }
    Ok(())
}

fn generate_pkgconfig_file(output_dir: &Path) {
    let pkg_config_content = format!(
        r#"prefix={prefix}
exec_prefix=${{prefix}}
libdir=${{exec_prefix}}/lib
includedir=${{prefix}}/include

Name: trustformers-c
Description: TrustformeRS C API - High-performance transformer library
Version: {version}
Libs: -L${{libdir}} -ltrustformers_c
Cflags: -I${{includedir}}
"#,
        prefix = output_dir.parent().unwrap().display(),
        version = env::var("CARGO_PKG_VERSION").unwrap()
    );

    let pkgconfig_path = output_dir.join("trustformers-c.pc");
    fs::write(pkgconfig_path, pkg_config_content).expect("Failed to write pkg-config file");
}

fn generate_cmake_config(output_dir: &Path) {
    let cmake_config_content = format!(
        r#"# TrustformeRS CMake Configuration
# Generated automatically by build script

set(TRUSTFORMERS_VERSION "{version}")
set(TRUSTFORMERS_INCLUDE_DIR "{include_dir}")
set(TRUSTFORMERS_LIBRARY_DIR "{lib_dir}")

# Find library
find_library(TRUSTFORMERS_LIBRARY
    NAMES trustformers_c
    PATHS "${{TRUSTFORMERS_LIBRARY_DIR}}"
    NO_DEFAULT_PATH
)

if(TRUSTFORMERS_LIBRARY)
    set(TRUSTFORMERS_FOUND TRUE)
else()
    set(TRUSTFORMERS_FOUND FALSE)
endif()

# Create imported target
if(TRUSTFORMERS_FOUND AND NOT TARGET TrustformeRS::trustformers_c)
    add_library(TrustformeRS::trustformers_c SHARED IMPORTED)
    set_target_properties(TrustformeRS::trustformers_c PROPERTIES
        IMPORTED_LOCATION "${{TRUSTFORMERS_LIBRARY}}"
        INTERFACE_INCLUDE_DIRECTORIES "${{TRUSTFORMERS_INCLUDE_DIR}}"
    )
endif()

# Variables for find_package
set(TRUSTFORMERS_LIBRARIES ${{TRUSTFORMERS_LIBRARY}})
set(TRUSTFORMERS_INCLUDE_DIRS ${{TRUSTFORMERS_INCLUDE_DIR}})

# Status message
if(TRUSTFORMERS_FOUND)
    message(STATUS "Found TrustformeRS: ${{TRUSTFORMERS_LIBRARY}} (version ${{TRUSTFORMERS_VERSION}})")
else()
    if(TrustformeRS_FIND_REQUIRED)
        message(FATAL_ERROR "Could not find TrustformeRS library")
    else()
        message(STATUS "Could not find TrustformeRS library")
    endif()
endif()
"#,
        version = env::var("CARGO_PKG_VERSION").unwrap(),
        include_dir = output_dir.display(),
        lib_dir = output_dir.parent().unwrap().join("lib").display()
    );

    let cmake_config_path = output_dir.join("TrustformeRSConfig.cmake");
    fs::write(cmake_config_path, cmake_config_content).expect("Failed to write CMake config file");

    // Generate version file for CMake
    let cmake_version_content = format!(
        r#"# TrustformeRS CMake Version File
set(PACKAGE_VERSION "{version}")

# Check whether the requested PACKAGE_FIND_VERSION is compatible
if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
    set(PACKAGE_VERSION_COMPATIBLE FALSE)
else()
    set(PACKAGE_VERSION_COMPATIBLE TRUE)
    if (PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)
        set(PACKAGE_VERSION_EXACT TRUE)
    endif()
endif()
"#,
        version = env::var("CARGO_PKG_VERSION").unwrap()
    );

    let cmake_version_path = output_dir.join("TrustformeRSConfigVersion.cmake");
    fs::write(cmake_version_path, cmake_version_content)
        .expect("Failed to write CMake version file");
}

fn generate_vcpkg_portfile(output_dir: &Path) {
    let vcpkg_portfile_content = format!(
        r#"vcpkg_from_github(
    OUT_SOURCE_PATH SOURCE_PATH
    REPO cool-japan/trustformers
    REF v{version}
    SHA512 0  # This should be updated with actual SHA512 hash
    HEAD_REF main
)

vcpkg_cmake_configure(
    SOURCE_PATH "${{SOURCE_PATH}}"
    GENERATOR "Ninja"
    OPTIONS
        -DBUILD_SHARED_LIBS=ON
        -DBUILD_TESTING=OFF
        -DCMAKE_BUILD_TYPE=Release
)

vcpkg_cmake_build()
vcpkg_cmake_install()

# Handle copyright
vcpkg_install_copyright(FILE_LIST "${{SOURCE_PATH}}/LICENSE")

# Fix CMake targets
vcpkg_cmake_config_fixup(
    PACKAGE_NAME TrustformeRS
    CONFIG_PATH lib/cmake/TrustformeRS
)

# Remove duplicate files
file(REMOVE_RECURSE "${{CURRENT_PACKAGES_DIR}}/debug/include")
file(REMOVE_RECURSE "${{CURRENT_PACKAGES_DIR}}/debug/share")

# Install pkg-config file
if(NOT VCPKG_CMAKE_SYSTEM_NAME OR VCPKG_CMAKE_SYSTEM_NAME STREQUAL "Linux")
    vcpkg_replace_string(
        "${{CURRENT_PACKAGES_DIR}}/lib/pkgconfig/trustformers-c.pc"
        "${{CURRENT_INSTALLED_DIR}}"
        "${{CURRENT_PACKAGES_DIR}}"
    )
    vcpkg_replace_string(
        "${{CURRENT_PACKAGES_DIR}}/debug/lib/pkgconfig/trustformers-c.pc"
        "${{CURRENT_INSTALLED_DIR}}"
        "${{CURRENT_PACKAGES_DIR}}"
    )
endif()
"#,
        version = env::var("CARGO_PKG_VERSION").unwrap()
    );

    let vcpkg_portfile_path = output_dir.join("portfile.cmake");
    fs::write(vcpkg_portfile_path, vcpkg_portfile_content).expect("Failed to write vcpkg portfile");

    // Generate vcpkg.json manifest
    let vcpkg_manifest_content = format!(
        r#"{{
    "name": "trustformers-c",
    "version": "{version}",
    "description": "TrustformeRS C API - High-performance transformer library",
    "homepage": "https://github.com/cool-japan/trustformers",
    "license": "MIT",
    "supports": "!(arm32 | wasm32)",
    "dependencies": [
        {{
            "name": "vcpkg-cmake",
            "host": true
        }},
        {{
            "name": "vcpkg-cmake-config",
            "host": true
        }}
    ],
    "features": {{
        "cuda": {{
            "description": "Enable CUDA support",
            "dependencies": [
                "cuda"
            ]
        }},
        "openmp": {{
            "description": "Enable OpenMP support",
            "dependencies": [
                "openmp"
            ]
        }}
    }}
}}"#,
        version = env::var("CARGO_PKG_VERSION").unwrap()
    );

    let vcpkg_manifest_path = output_dir.join("vcpkg.json");
    fs::write(vcpkg_manifest_path, vcpkg_manifest_content).expect("Failed to write vcpkg manifest");
}

fn generate_meson_build(output_dir: &Path) {
    let meson_build_content = format!(
        r#"# TrustformeRS Meson Build Configuration
# Generated automatically by build script

project('trustformers-c',
    'c',
    version: '{version}',
    license: 'MIT',
    meson_version: '>=0.50.0',
    default_options: [
        'warning_level=3',
        'werror=false',
        'c_std=c11',
        'buildtype=release',
        'default_library=shared'
    ]
)

# Library configuration
trustformers_c_lib = library('trustformers_c',
    # Sources would be added here for a traditional C build
    # For Rust-based builds, this serves as documentation
    install: true,
    install_dir: get_option('libdir'),
    version: meson.project_version(),
    soversion: '0'
)

# Install headers
install_headers(
    'trustformers.h',
    subdir: 'trustformers-c'
)

# Generate pkg-config file
pkg = import('pkgconfig')
pkg.generate(
    trustformers_c_lib,
    name: 'trustformers-c',
    description: 'TrustformeRS C API - High-performance transformer library',
    version: meson.project_version(),
    url: 'https://github.com/cool-japan/trustformers',
    requires: [],
    libraries: ['-ltrustformers_c'],
    libraries_private: ['-lm', '-ldl', '-lpthread'],
    subdirs: ['trustformers-c']
)

# Create a dependency object for other projects
trustformers_c_dep = declare_dependency(
    link_with: trustformers_c_lib,
    include_directories: include_directories('.')
)

# Summary
summary({{
    'prefix': get_option('prefix'),
    'libdir': get_option('libdir'),
    'includedir': get_option('includedir'),
    'version': meson.project_version(),
}}, section: 'Configuration')
"#,
        version = env::var("CARGO_PKG_VERSION").unwrap()
    );

    let meson_build_path = output_dir.join("meson.build");
    fs::write(meson_build_path, meson_build_content).expect("Failed to write meson build file");

    // Generate meson.options file
    let meson_options_content = r#"# TrustformeRS Meson Build Options

option('cuda',
    type: 'boolean',
    value: false,
    description: 'Enable CUDA support'
)

option('openmp',
    type: 'boolean',
    value: false,
    description: 'Enable OpenMP support'
)

option('examples',
    type: 'boolean',
    value: false,
    description: 'Build examples'
)

option('tests',
    type: 'boolean',
    value: false,
    description: 'Build tests'
)

option('docs',
    type: 'boolean',
    value: false,
    description: 'Build documentation'
)
"#;

    let meson_options_path = output_dir.join("meson.options");
    fs::write(meson_options_path, meson_options_content)
        .expect("Failed to write meson options file");
}

fn apply_cross_platform_optimizations() {
    let target_arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();
    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
    let target_env = env::var("CARGO_CFG_TARGET_ENV").unwrap_or_default();

    // Note: target_arch and target_os are built-in cfg flags and should not be set manually

    match target_arch.as_str() {
        "aarch64" => {
            println!("cargo:rustc-cfg=arm64");
            // ARM64 optimizations
            println!("cargo:rustc-link-arg=-Wl,-dead_strip"); // Remove dead code

            if target_os == "macos" {
                println!("cargo:rustc-cfg=apple_silicon");
                // Apple Silicon specific optimizations
                println!("cargo:rustc-link-arg=-framework");
                println!("cargo:rustc-link-arg=Accelerate");
                println!("cargo:rustc-link-arg=-framework");
                println!("cargo:rustc-link-arg=CoreML");
                println!("cargo:rustc-link-arg=-framework");
                println!("cargo:rustc-link-arg=MetalKit");

                // Compile Metal implementation
                compile_metal_implementation();
            }
        },
        "x86_64" => {
            // x86_64 optimizations
            if target_os == "windows" {
                println!("cargo:rustc-cfg=windows_dll");
                // Windows DLL export optimizations
                println!("cargo:rustc-link-arg=/INCREMENTAL:NO");
                println!("cargo:rustc-link-arg=/OPT:REF,ICF");
                println!("cargo:rustc-link-arg=/LTCG");

                if target_env == "msvc" {
                    // MSVC specific optimizations
                    println!("cargo:rustc-link-lib=kernel32");
                    println!("cargo:rustc-link-lib=user32");
                    println!("cargo:rustc-link-lib=advapi32");
                }
            } else if target_os == "macos" {
                // macOS x86_64 optimizations
                println!("cargo:rustc-link-arg=-framework");
                println!("cargo:rustc-link-arg=Accelerate");
                println!("cargo:rustc-link-arg=-Wl,-dead_strip");
            }
        },
        "wasm32" => {
            // WebAssembly optimizations
            println!("cargo:rustc-cfg=wasm");

            // Enable WASM-specific optimizations
            println!("cargo:rustc-link-arg=--export-dynamic");
            println!("cargo:rustc-link-arg=--no-gc-sections");

            // WASM SIMD support if available
            if env::var("CARGO_CFG_TARGET_FEATURE").unwrap_or_default().contains("simd128") {
                println!("cargo:rustc-cfg=wasm_simd");
            }

            // WASM threads support if available
            if env::var("CARGO_CFG_TARGET_FEATURE").unwrap_or_default().contains("atomics") {
                println!("cargo:rustc-cfg=wasm_threads");
            }

            // Set memory configuration for WASM
            println!("cargo:rustc-link-arg=--initial-memory=16777216"); // 16MB initial
            println!("cargo:rustc-link-arg=--max-memory=268435456"); // 256MB max

            // Enable bulk memory operations if supported
            if env::var("CARGO_CFG_TARGET_FEATURE").unwrap_or_default().contains("bulk-memory") {
                println!("cargo:rustc-link-arg=--enable-bulk-memory");
            }
        },
        _ => {
            // Default optimizations for other architectures
            println!(
                "cargo:warning=Building for unsupported architecture: {}",
                target_arch
            );
        },
    }

    // Universal binary support for macOS
    if target_os == "macos" {
        println!("cargo:rustc-cfg=universal_binary");
        // Set deployment target for compatibility
        println!("cargo:rustc-env=MACOSX_DEPLOYMENT_TARGET=10.12");

        // Link against system libraries
        println!("cargo:rustc-link-lib=framework=Foundation");
        println!("cargo:rustc-link-lib=framework=CoreFoundation");
        println!("cargo:rustc-link-lib=framework=Security");
    }

    // SIMD optimizations (available on most modern platforms)
    if target_arch == "x86_64" || target_arch == "aarch64" || target_arch == "wasm32" {
        println!("cargo:rustc-cfg=simd");
        if target_arch == "x86_64" {
            println!("cargo:rustc-cfg=avx2");
        } else if target_arch == "aarch64" {
            println!("cargo:rustc-cfg=neon");
        } else if target_arch == "wasm32" {
            // WASM SIMD is detected above in target-specific section
        }
    }

    // Enable LTO for release builds
    if env::var("PROFILE").unwrap_or_default() == "release" {
        println!("cargo:rustc-lto=true");
    }

    // Cross-compilation helpers
    if env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default()
        != env::var("CARGO_CFG_HOST_ARCH").unwrap_or_default()
    {
        println!("cargo:rustc-cfg=cross_compiling");
        println!("cargo:warning=Cross-compiling for {}", target_arch);
    }
}

fn compile_metal_implementation() {
    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();

    if target_os != "macos" {
        return;
    }

    // Compile Metal implementation for macOS
    println!("cargo:rerun-if-changed=src/platform/metal_impl.m");

    cc::Build::new()
        .file("src/platform/metal_impl.m")
        .flag("-fobjc-arc") // Enable ARC
        .flag("-framework")
        .flag("Foundation")
        .flag("-framework")
        .flag("Metal")
        .flag("-framework")
        .flag("MetalPerformanceShaders")
        .flag("-framework")
        .flag("CoreGraphics")
        .compile("metal_impl");

    println!("cargo:rustc-link-lib=static=metal_impl");
    println!("cargo:rustc-link-lib=framework=Foundation");
    println!("cargo:rustc-link-lib=framework=Metal");
    println!("cargo:rustc-link-lib=framework=MetalPerformanceShaders");
    println!("cargo:rustc-link-lib=framework=CoreGraphics");
}

/// Automated header file synchronization system
fn automated_header_sync(crate_dir: &str, output_dir: &PathBuf) {
    println!("cargo:warning=Running automated header file synchronization...");

    // Configuration for header synchronization
    let mut sync_config = HeaderSyncConfig::new();

    // Add Rust source files to monitor
    let src_dir = PathBuf::from(crate_dir).join("src");
    if src_dir.exists() {
        scan_rust_files(&src_dir, &mut sync_config);
    }

    // Generate function signatures
    let signatures = extract_c_function_signatures(&src_dir);

    // Check for ABI compatibility
    check_abi_compatibility(&signatures, output_dir);

    // Synchronize header files
    synchronize_headers(&sync_config, output_dir, &signatures);

    // Generate version-specific headers
    generate_versioned_headers(output_dir);

    // Create header dependency map
    create_header_dependency_map(output_dir);

    // Validate header consistency
    validate_header_consistency(output_dir);

    println!("cargo:warning=Header synchronization completed successfully");
}

/// Configuration for header synchronization
#[derive(Debug)]
struct HeaderSyncConfig {
    /// Files to monitor for changes
    monitored_files: Vec<PathBuf>,
    /// Function signatures found
    function_signatures: HashMap<String, FunctionSignature>,
    /// Header file dependencies
    #[allow(dead_code)]
    dependencies: HashMap<String, Vec<String>>,
    /// Synchronization rules
    #[allow(dead_code)]
    sync_rules: Vec<SyncRule>,
}

/// Function signature information
#[derive(Debug, Clone)]
struct FunctionSignature {
    name: String,
    return_type: String,
    parameters: Vec<Parameter>,
    #[allow(dead_code)]
    is_extern_c: bool,
    #[allow(dead_code)]
    is_no_mangle: bool,
    #[allow(dead_code)]
    documentation: Option<String>,
    file_path: String,
    #[allow(dead_code)]
    line_number: usize,
}

#[derive(Debug, Clone)]
struct Parameter {
    name: String,
    param_type: String,
    is_const: bool,
    is_pointer: bool,
}

/// Synchronization rule
#[derive(Debug)]
struct SyncRule {
    #[allow(dead_code)]
    source_pattern: String,
    #[allow(dead_code)]
    target_pattern: String,
    #[allow(dead_code)]
    transform: SyncTransform,
}

#[derive(Debug)]
enum SyncTransform {
    #[allow(dead_code)]
    DirectCopy,
    FunctionExtraction,
    TypeDefinitionExtraction,
    #[allow(dead_code)]
    ConstantExtraction,
}

impl HeaderSyncConfig {
    fn new() -> Self {
        Self {
            monitored_files: Vec::new(),
            function_signatures: HashMap::new(),
            dependencies: HashMap::new(),
            sync_rules: vec![
                SyncRule {
                    source_pattern: "*.rs".to_string(),
                    target_pattern: "trustformers.h".to_string(),
                    transform: SyncTransform::FunctionExtraction,
                },
                SyncRule {
                    source_pattern: "error.rs".to_string(),
                    target_pattern: "trustformers_errors.h".to_string(),
                    transform: SyncTransform::TypeDefinitionExtraction,
                },
            ],
        }
    }

    fn add_monitored_file(&mut self, file_path: PathBuf) {
        self.monitored_files.push(file_path);
    }

    fn add_function_signature(&mut self, signature: FunctionSignature) {
        self.function_signatures.insert(signature.name.clone(), signature);
    }
}

/// Scan Rust files for C API functions
fn scan_rust_files(src_dir: &PathBuf, config: &mut HeaderSyncConfig) {
    if let Ok(entries) = fs::read_dir(src_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("rs") {
                config.add_monitored_file(path.clone());

                // Parse file for C API functions
                if let Ok(content) = fs::read_to_string(&path) {
                    parse_rust_file_for_c_functions(&content, &path, config);
                }
            } else if path.is_dir() {
                scan_rust_files(&path, config);
            }
        }
    }
}

/// Parse Rust file content for C API function signatures
fn parse_rust_file_for_c_functions(content: &str, file_path: &Path, config: &mut HeaderSyncConfig) {
    let lines: Vec<&str> = content.lines().collect();
    let _in_extern_c = false;
    let mut current_docs = Vec::new();
    let mut i = 0;

    while i < lines.len() {
        let line = lines[i].trim();

        // Check for documentation comments
        if line.starts_with("///") || line.starts_with("//!") {
            current_docs.push(line.trim_start_matches("///").trim_start_matches("//!").trim());
            i += 1;
            continue;
        }

        // Check for #[no_mangle] attribute
        let has_no_mangle = line.contains("#[no_mangle]");
        if has_no_mangle {
            i += 1;
            if i >= lines.len() {
                continue;
            }

            let next_line = lines[i].trim();
            // Check for extern "C" function
            if !(next_line.contains("extern \"C\"") && next_line.contains("fn ")) {
                continue;
            }

            let docs_strings: Vec<String> = current_docs.iter().map(|s| s.to_string()).collect();
            if let Some(signature) =
                parse_function_signature(next_line, &docs_strings, file_path, i + 1)
            {
                config.add_function_signature(signature);
            }
        }

        // Reset documentation for next function
        if !line.is_empty()
            && !line.starts_with("///")
            && !line.starts_with("//!")
            && !line.starts_with("#[")
        {
            current_docs.clear();
        }

        i += 1;
    }
}

/// Parse a function signature from a Rust function declaration
fn parse_function_signature(
    line: &str,
    docs: &[String],
    file_path: &Path,
    line_number: usize,
) -> Option<FunctionSignature> {
    // Simple regex-like parsing for function signatures
    let fn_start = line.find("fn ")?;
    let after_fn = &line[fn_start + 3..];

    let paren_start = after_fn.find('(')?;
    let fn_name = after_fn[..paren_start].trim();

    let paren_end = after_fn.find(')')?;
    let params_str = &after_fn[paren_start + 1..paren_end];
    let params = parse_parameters(params_str);

    // Extract return type
    let return_type = extract_return_type(after_fn);

    Some(FunctionSignature {
        name: fn_name.to_string(),
        return_type,
        parameters: params,
        is_extern_c: line.contains("extern \"C\""),
        is_no_mangle: true, // We only get here from #[no_mangle] functions
        documentation: if docs.is_empty() { None } else { Some(docs.join(" ")) },
        file_path: file_path.to_string_lossy().to_string(),
        line_number,
    })
}

/// Extract return type from function signature
fn extract_return_type(after_fn: &str) -> String {
    if let Some(arrow_pos) = after_fn.find("->") {
        let return_part = &after_fn[arrow_pos + 2..];
        if let Some(brace_pos) = return_part.find('{') {
            return_part[..brace_pos].trim().to_string()
        } else {
            return_part.trim().to_string()
        }
    } else {
        "void".to_string()
    }
}

/// Parse function parameters from parameter string
fn parse_parameters(params_str: &str) -> Vec<Parameter> {
    let mut parameters = Vec::new();

    if params_str.trim().is_empty() {
        return parameters;
    }

    for param in params_str.split(',') {
        let param = param.trim();
        if param.is_empty() {
            continue;
        }

        // Split on last colon to separate name and type
        if let Some(colon_pos) = param.rfind(':') {
            let name = param[..colon_pos].trim();
            let param_type = param[colon_pos + 1..].trim();

            let is_const = param_type.contains("*const");
            let is_pointer = param_type.contains('*');

            parameters.push(Parameter {
                name: name.to_string(),
                param_type: param_type.to_string(),
                is_const,
                is_pointer,
            });
        }
    }

    parameters
}

/// Extract C function signatures from compiled binary (alternative approach)
fn extract_c_function_signatures(_src_dir: &Path) -> Vec<FunctionSignature> {
    let signatures = Vec::new();

    // This is a simplified version - in practice, you'd use more sophisticated tools
    // like nm, objdump, or parse debug symbols

    // For now, we'll rely on the scanning approach above
    println!("cargo:warning=Using source-based signature extraction");

    signatures
}

/// Check ABI compatibility between versions
fn check_abi_compatibility(signatures: &[FunctionSignature], output_dir: &Path) {
    let abi_check_file = output_dir.join("abi_compatibility.json");

    // Load previous ABI signature if it exists
    let previous_abi = if abi_check_file.exists() {
        fs::read_to_string(&abi_check_file)
            .ok()
            .and_then(|content| serde_json::from_str::<serde_json::Value>(&content).ok())
    } else {
        None
    };

    // Create current ABI signature
    let current_abi = serde_json::json!({
        "version": env::var("CARGO_PKG_VERSION").unwrap(),
        "timestamp": std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs(),
        "functions": signatures.iter().map(|sig| {
            serde_json::json!({
                "name": sig.name,
                "return_type": sig.return_type,
                "parameters": sig.parameters.iter().map(|p| {
                    serde_json::json!({
                        "name": p.name,
                        "type": p.param_type,
                        "is_const": p.is_const,
                        "is_pointer": p.is_pointer
                    })
                }).collect::<Vec<_>>()
            })
        }).collect::<Vec<_>>()
    });

    // Check compatibility if previous version exists
    if let Some(prev_abi) = previous_abi {
        let compatibility_issues = check_abi_differences(&prev_abi, &current_abi);
        if !compatibility_issues.is_empty() {
            println!("cargo:warning=ABI compatibility issues detected:");
            for issue in compatibility_issues {
                println!("cargo:warning=  - {}", issue);
            }
        }
    }

    // Save current ABI signature
    if let Ok(abi_json) = serde_json::to_string_pretty(&current_abi) {
        let _ = fs::write(abi_check_file, abi_json);
    }
}

/// Check differences between ABI versions
fn check_abi_differences(
    prev_abi: &serde_json::Value,
    current_abi: &serde_json::Value,
) -> Vec<String> {
    let mut issues = Vec::new();

    let empty_vec = vec![];
    let prev_functions = prev_abi["functions"].as_array().unwrap_or(&empty_vec);
    let current_functions = current_abi["functions"].as_array().unwrap_or(&empty_vec);

    // Check for removed functions
    for prev_func in prev_functions {
        let func_name = prev_func["name"].as_str().unwrap_or("");
        let found = current_functions.iter().any(|f| f["name"].as_str() == Some(func_name));
        if !found {
            issues.push(format!("Function '{}' was removed", func_name));
        }
    }

    // Check for changed function signatures
    for current_func in current_functions {
        let func_name = current_func["name"].as_str().unwrap_or("");
        if let Some(prev_func) =
            prev_functions.iter().find(|f| f["name"].as_str() == Some(func_name))
        {
            if prev_func["return_type"] != current_func["return_type"] {
                issues.push(format!("Function '{}' return type changed", func_name));
            }

            let empty_params = vec![];
            let prev_params = prev_func["parameters"].as_array().unwrap_or(&empty_params);
            let current_params = current_func["parameters"].as_array().unwrap_or(&empty_params);

            if prev_params.len() != current_params.len() {
                issues.push(format!("Function '{}' parameter count changed", func_name));
            }
        }
    }

    issues
}

/// Synchronize header files based on configuration
fn synchronize_headers(
    _config: &HeaderSyncConfig,
    output_dir: &Path,
    signatures: &[FunctionSignature],
) {
    // Generate main header file
    generate_main_header(output_dir, signatures);

    // Generate module-specific headers
    generate_module_headers(output_dir, signatures);

    // Generate compatibility headers
    generate_compatibility_headers(output_dir);

    println!(
        "cargo:warning=Generated {} function signatures",
        signatures.len()
    );
}

/// Generate the main header file
fn generate_main_header(output_dir: &Path, signatures: &[FunctionSignature]) {
    let header_path = output_dir.join("trustformers_complete.h");

    let mut header_content = String::new();
    header_content.push_str(&format!(
        "/* TrustformeRS Complete C API Header\n * Version: {}\n * Generated: {}\n * DO NOT EDIT - This file is automatically generated\n */\n\n",
        env::var("CARGO_PKG_VERSION").unwrap(),
        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    ));

    header_content.push_str("#ifndef TRUSTFORMERS_COMPLETE_H\n");
    header_content.push_str("#define TRUSTFORMERS_COMPLETE_H\n\n");

    header_content.push_str("#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");

    header_content.push_str("#include <stdint.h>\n");
    header_content.push_str("#include <stdlib.h>\n");
    header_content.push_str("#include <stdbool.h>\n\n");

    // Group functions by module
    let mut modules: HashMap<String, Vec<&FunctionSignature>> = HashMap::new();
    for sig in signatures {
        let module = extract_module_from_path(&sig.file_path);
        modules.entry(module).or_default().push(sig);
    }

    for (module, sigs) in modules {
        if sigs.is_empty() {
            continue;
        }

        header_content.push_str(&format!("/* {} Functions */\n", module));
        for sig in sigs {
            if let Some(doc) = &sig.documentation {
                header_content.push_str(&format!("/**\n * {}\n */\n", doc));
            }

            let c_signature = convert_to_c_signature(sig);
            header_content.push_str(&format!("{};\n\n", c_signature));
        }
    }

    header_content.push_str("#ifdef __cplusplus\n}\n#endif\n\n");
    header_content.push_str("#endif /* TRUSTFORMERS_COMPLETE_H */\n");

    let _ = fs::write(header_path, header_content);
}

/// Generate module-specific headers
fn generate_module_headers(output_dir: &Path, signatures: &[FunctionSignature]) {
    let mut modules: HashMap<String, Vec<&FunctionSignature>> = HashMap::new();

    for sig in signatures {
        let module = extract_module_from_path(&sig.file_path);
        modules.entry(module).or_default().push(sig);
    }

    for (module, sigs) in modules {
        if sigs.is_empty() {
            continue;
        }

        let header_path = output_dir.join(format!("trustformers_{}.h", module.to_lowercase()));
        let guard_name = format!("TRUSTFORMERS_{}_H", module.to_uppercase());

        let mut header_content = String::new();
        header_content.push_str(&format!(
            "/* TrustformeRS {} Module Header */\n#ifndef {}\n#define {}\n\n",
            module, guard_name, guard_name
        ));

        header_content.push_str("#include \"trustformers.h\"\n\n");

        for sig in sigs {
            let c_signature = convert_to_c_signature(sig);
            header_content.push_str(&format!("{};\n", c_signature));
        }

        header_content.push_str(&format!("\n#endif /* {} */\n", guard_name));

        let _ = fs::write(header_path, header_content);
    }
}

/// Generate compatibility headers for different versions
fn generate_compatibility_headers(output_dir: &Path) {
    let compat_header_path = output_dir.join("trustformers_compat.h");

    let compat_content = format!(
        r#"/* TrustformeRS Compatibility Header
 * Provides compatibility definitions for different versions
 */
#ifndef TRUSTFORMERS_COMPAT_H
#define TRUSTFORMERS_COMPAT_H

#include "trustformers.h"

/* Version information */
#define TRUSTFORMERS_VERSION_MAJOR {}
#define TRUSTFORMERS_VERSION_MINOR {}
#define TRUSTFORMERS_VERSION_PATCH {}
#define TRUSTFORMERS_VERSION_STRING "{}"

/* Compatibility macros */
#if defined(__GNUC__) && (__GNUC__ >= 4)
    #define TRUSTFORMERS_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
    #define TRUSTFORMERS_DEPRECATED __declspec(deprecated)
#else
    #define TRUSTFORMERS_DEPRECATED
#endif

/* Platform-specific definitions */
#ifdef _WIN32
    #define TRUSTFORMERS_EXPORT __declspec(dllexport)
    #define TRUSTFORMERS_IMPORT __declspec(dllimport)
#else
    #define TRUSTFORMERS_EXPORT __attribute__((visibility("default")))
    #define TRUSTFORMERS_IMPORT
#endif

#ifdef TRUSTFORMERS_STATIC
    #define TRUSTFORMERS_API
#elif defined(TRUSTFORMERS_EXPORTS)
    #define TRUSTFORMERS_API TRUSTFORMERS_EXPORT
#else
    #define TRUSTFORMERS_API TRUSTFORMERS_IMPORT
#endif

#endif /* TRUSTFORMERS_COMPAT_H */
"#,
        env::var("CARGO_PKG_VERSION_MAJOR").unwrap_or("0".to_string()),
        env::var("CARGO_PKG_VERSION_MINOR").unwrap_or("1".to_string()),
        env::var("CARGO_PKG_VERSION_PATCH").unwrap_or("0".to_string()),
        env::var("CARGO_PKG_VERSION").unwrap()
    );

    let _ = fs::write(compat_header_path, compat_content);
}

/// Generate versioned headers for API evolution
fn generate_versioned_headers(output_dir: &PathBuf) {
    let version = env::var("CARGO_PKG_VERSION").unwrap();
    let version_dir = output_dir.join("versions").join(&version);

    let _ = fs::create_dir_all(&version_dir);

    // Copy main headers to versioned directory
    for entry in fs::read_dir(output_dir).unwrap().flatten() {
        if entry.path().extension().and_then(|s| s.to_str()) == Some("h") {
            let target = version_dir.join(entry.file_name());
            let _ = fs::copy(entry.path(), target);
        }
    }
}

/// Create header dependency map
fn create_header_dependency_map(output_dir: &PathBuf) {
    let mut deps = HashMap::new();

    // Analyze header dependencies
    if let Ok(entries) = fs::read_dir(output_dir) {
        for entry in entries.flatten() {
            if entry.path().extension().and_then(|s| s.to_str()) == Some("h") {
                let file_deps = analyze_header_dependencies(&entry.path());
                deps.insert(entry.file_name().to_string_lossy().to_string(), file_deps);
            }
        }
    }

    // Write dependency map
    let deps_json = serde_json::to_string_pretty(&deps).unwrap_or_default();
    let deps_path = output_dir.join("header_dependencies.json");
    let _ = fs::write(deps_path, deps_json);
}

/// Analyze dependencies for a header file
fn analyze_header_dependencies(header_path: &PathBuf) -> Vec<String> {
    let mut dependencies = Vec::new();

    if let Ok(content) = fs::read_to_string(header_path) {
        for line in content.lines() {
            let line = line.trim();
            if line.starts_with("#include \"") && line.ends_with("\"") {
                let include = &line[10..line.len() - 1]; // Remove #include " and "
                dependencies.push(include.to_string());
            }
        }
    }

    dependencies
}

/// Validate header consistency
fn validate_header_consistency(output_dir: &Path) {
    let mut issues = Vec::new();

    // Check for circular dependencies
    let deps_path = output_dir.join("header_dependencies.json");
    if let Ok(deps_content) = fs::read_to_string(deps_path) {
        if let Ok(deps) = serde_json::from_str::<HashMap<String, Vec<String>>>(&deps_content) {
            for header in deps.keys() {
                if has_circular_dependency(header, &deps, &mut Vec::new()) {
                    issues.push(format!("Circular dependency detected in {}", header));
                }
            }
        }
    }

    // Report issues
    if !issues.is_empty() {
        println!("cargo:warning=Header validation issues:");
        for issue in issues {
            println!("cargo:warning=  - {}", issue);
        }
    }
}

/// Check for circular dependencies
fn has_circular_dependency(
    header: &str,
    deps: &HashMap<String, Vec<String>>,
    path: &mut Vec<String>,
) -> bool {
    if path.contains(&header.to_string()) {
        return true;
    }

    path.push(header.to_string());

    if let Some(header_deps) = deps.get(header) {
        for dep in header_deps {
            if has_circular_dependency(dep, deps, path) {
                return true;
            }
        }
    }

    path.pop();
    false
}

/// Extract module name from file path
fn extract_module_from_path(file_path: &str) -> String {
    if let Some(file_name) = PathBuf::from(file_path).file_stem() {
        file_name.to_string_lossy().to_string()
    } else {
        "unknown".to_string()
    }
}

/// Convert Rust function signature to C signature
fn convert_to_c_signature(sig: &FunctionSignature) -> String {
    let mut c_sig = String::new();

    // Add return type
    let c_return_type = rust_type_to_c_type(&sig.return_type);
    c_sig.push_str(&c_return_type);
    c_sig.push(' ');

    // Add function name
    c_sig.push_str(&sig.name);
    c_sig.push('(');

    // Add parameters
    if sig.parameters.is_empty() {
        c_sig.push_str("void");
    } else {
        let param_strs: Vec<String> = sig
            .parameters
            .iter()
            .map(|p| {
                let c_type = rust_type_to_c_type(&p.param_type);
                format!("{} {}", c_type, p.name)
            })
            .collect();
        c_sig.push_str(&param_strs.join(", "));
    }

    c_sig.push(')');
    c_sig
}

/// Generate a manual header file as fallback when cbindgen fails
fn generate_manual_header() -> String {
    format!(
        r#"/* TrustformeRS C API
 * High-performance transformer library for machine learning
 *
 * Generated manually as fallback when cbindgen fails
 * Version: {}
 */

#ifndef TRUSTFORMERS_H
#define TRUSTFORMERS_H

#ifdef __cplusplus
extern "C" {{
#endif

#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stddef.h>

/* Version information */
#define TRUSTFORMERS_VERSION_MAJOR 0
#define TRUSTFORMERS_VERSION_MINOR 1
#define TRUSTFORMERS_VERSION_PATCH 0

/* API calling convention */
#ifndef TRUSTFORMERS_API
#  ifdef _WIN32
#    ifdef TRUSTFORMERS_EXPORTS
#      define TRUSTFORMERS_API __declspec(dllexport)
#    else
#      define TRUSTFORMERS_API __declspec(dllimport)
#    endif
#  else
#    define TRUSTFORMERS_API
#  endif
#endif

/* Forward declarations */
typedef struct TrustformersModel TrustformersModel;
typedef struct TrustformersPipeline TrustformersPipeline;
typedef struct TrustformersTokenizer TrustformersTokenizer;

/* Error codes */
typedef enum {{
    TRUSTFORMERS_SUCCESS = 0,
    TRUSTFORMERS_ERROR_NULL_POINTER = 1,
    TRUSTFORMERS_ERROR_INVALID_PARAMETER = 2,
    TRUSTFORMERS_ERROR_MEMORY_ERROR = 3,
    TRUSTFORMERS_ERROR_IO_ERROR = 4,
    TRUSTFORMERS_ERROR_RUNTIME_ERROR = 5,
}} TrustformersError;

/* Basic API functions - these should be implemented in the actual library */
TRUSTFORMERS_API TrustformersError trustformers_init(void);
TRUSTFORMERS_API void trustformers_cleanup(void);
TRUSTFORMERS_API const char* trustformers_get_version(void);
TRUSTFORMERS_API const char* trustformers_get_error_message(TrustformersError error);

#ifdef __cplusplus
}}
#endif

#endif /* TRUSTFORMERS_H */
"#,
        env::var("CARGO_PKG_VERSION").unwrap_or_else(|_| "0.1.0".to_string())
    )
}

/// Convert Rust type to C type
fn rust_type_to_c_type(rust_type: &str) -> String {
    match rust_type.trim() {
        "i8" => "int8_t".to_string(),
        "i16" => "int16_t".to_string(),
        "i32" | "c_int" => "int32_t".to_string(),
        "i64" => "int64_t".to_string(),
        "u8" => "uint8_t".to_string(),
        "u16" => "uint16_t".to_string(),
        "u32" => "uint32_t".to_string(),
        "u64" => "uint64_t".to_string(),
        "f32" => "float".to_string(),
        "f64" | "c_double" => "double".to_string(),
        "bool" => "bool".to_string(),
        "usize" => "size_t".to_string(),
        "isize" => "ptrdiff_t".to_string(),
        "*const c_char" => "const char*".to_string(),
        "*mut c_char" => "char*".to_string(),
        "*const c_void" => "const void*".to_string(),
        "*mut c_void" => "void*".to_string(),
        "TrustformersError" => "TrustformersError".to_string(),
        "()" => "void".to_string(),
        _ => {
            // Handle more complex types
            if let Some(stripped) = rust_type.strip_prefix("*const ") {
                format!("const {}*", rust_type_to_c_type(stripped))
            } else if let Some(stripped) = rust_type.strip_prefix("*mut ") {
                format!("{}*", rust_type_to_c_type(stripped))
            } else {
                rust_type.to_string()
            }
        },
    }
}
